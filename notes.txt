let grid = new Array(20).fill(0).map(row => new Array(20).fill(0));


  const isInBounds = (row, col) => {
  return (row < rowNum && row >= 0) && (col < colNum && col >= 0);
};


intermediateSpace = (current, prev) => {
  [currentRow, currentCol] = current;
  [prevRow, prevCol] = prev;
  intermediateRow = (currentRow + prevRow) / 2;
  intermediateCol = (currentCol + prevCol) / 2;
  return [intermediateRow, intermediateCol];
};


const openSpace = (pos, prev) => {
  [row, col] = pos;
  grid[row][col] = 1;

  if (prev) {
    [intRow, intCol] = intermediateSpace(pos, prev);
    grid[intRow][intCol] = 1;
  }

  surroundingPositions(pos).filter((surrounding) => {
    [surrX, surrY] = surrounding;
    if (!isValidSpace(surrounding)){
      [interX, interY] = intermediateSpace(pos, surrounding)
      if (grid[interX][interY] === 0){
      }
    }
  })
};

const isValidSpace = (pos) => {
  let [row, col] = pos;
  return isInBounds(row, col) && grid[row][col] === 0;
};

const surroundingPositions = (pos) => {
  let [row, col] = pos;
  let positions = [];
  positions.push([row - 2, col]);
  positions.push([row, col + 2]);
  positions.push([row + 2, col]);
  positions.push([row, col - 2]);
  return positions.filter(pos => {
    return isInBounds(pos[0], pos[1]);
  });
};

const validProbe = (probe) => {
  if (!isValidSpace(probe.pos)) return false;
  return true;
};

  const buildFrontier = (pos) => {
  let [row, col] = pos;
  let surroundingSquares = [];
  surroundingSquares.push({
    pos: [row - 2, col], prev: pos
  });
  surroundingSquares.push({
    pos: [row, col + 2], prev: pos
  });
  surroundingSquares.push({
    pos: [row + 2, col], prev: pos
  });
  surroundingSquares.push({
    pos: [row, col - 2], prev: pos
  });
  validSurrounding = surroundingSquares.filter(probe => validProbe(probe));
  frontier = frontier.concat(validSurrounding);
};

let startPos = [0, 0];

const hasOpening = (pos) => {
  return surroundingPositions(pos).filter(p => isValidSpace(p)).count > 0;
};


const buildWalker = (startPos) => {
  explorePath = [];
  openSpace(startPos);
  randomDir = surroundingPositions(startPos).randomPop();
  explorePath.push(randomDir);

  while(explorePath.length !== 0){
    randomDir = surroundingPositions(startPos).filter(p => isValidSpace(p)).randomPop();
    //remember, do NOT fill in the sqare connecting randomDir to start
    explorePath.forEach((pos, i) => {
      if (pos[0] === randomDir[0] && pos[1] === randomDir[1] )
      explorePath = explorePath.slice(0, i);
    })
    if (grid[randomDir] === 1){
      explorePath.forEach((pos) => {
        openSpace(pos);
      })
      explorePath = [];
    }
    grid.forEach((row) => {
      row.forEach((col) => {
        if (grid[row][col] === 1 && hasOpening([row, col])){
          randomDir = surroundingPositions(startPos).filter(p => isValidSpace(p)).randomPop();
          explorePath.push([row, col]);
        }
      })
    })

  }
}


console.log(grid)
