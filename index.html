<!DOCTYPE html>
<html>
<head>
<title>Grid using d3.js</title>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script type="text/javascript">

</script>
</head>
<body>

<div id="maze"></div>
<div id="mazed"></div>
<svg width="500" height="500"></svg>
<script type="text/javascript" src="grid.js"></script>
<script type="text/javascript">

</script>
</body>
</html>


  <script type="text/javascript">

  const rowNum = 50;
  const colNum = 50;
  let grid = new Array(rowNum).fill(0).map(row => new Array(colNum).fill(0));

  //Check if space is in bounds

  const isInBounds = (row, col) => {
    return (row < rowNum && row >= 0) && (col < colNum && col >= 0);
  };

  // I need a way to open spaces

  intermediateSpace = (current, prev) => {
    //use average!
    [currentRow, currentCol] = current;
    [prevRow, prevCol] = prev;
    intermediateRow = (currentRow + prevRow) / 2;
    intermediateCol = (currentCol + prevCol) / 2;
    return [intermediateRow, intermediateCol];
  };

  const openSpace = (pos, prev) => {
    [row, col] = pos;
    grid[row][col] = 1;
    paintWhite(pos)
    if (prev) {
      [intRow, intCol] = intermediateSpace(pos, prev);
      grid[intRow][intCol] = 1;
      paintWhite([intRow, intCol]);
    }

  };

  const isValidSpace = (pos) => {
    let [row, col] = pos;
    return isInBounds(row, col) && grid[row][col] === 0;
  };

  //surrounding positions
  const surroundingPositions = (pos) => {
    let [row, col] = pos;
    let positions = [];
    positions.push([row - 2, col]);
    positions.push([row, col + 2]);
    positions.push([row + 2, col]);
    positions.push([row, col - 2]);
    return positions.filter(pos => {
      return isInBounds(pos[0], pos[1]);
    });
  };



  const validProbe = (probe) => {
    //first, validate that the space is in bounds and empty using isValidSpace
    //lastly, should look at all directions except the one it came from, and return false if a space is opened
    if (!isValidSpace(probe.pos)) return false;
    return true;
    // let [row, col] = probe.pos;
    // if (row === 0 && col === 0) return false;
    // let [fromRow, fromCol] = probe.prev;
    // return surroundingPositions(probe.pos).every((border) => {
    //   [borderingRow, borderingCol] = border;
    //   return (fromRow === borderingRow && fromCol === borderingCol) || isValidSpace(border);
    // });
  };

  //need a function to build frontier, needs to take a move and store surrounding Positions as well as the directions.

  // when you make a new frontier, clear frontiers of all surrounding spaces and then replace with own.
  //this can be called absorb frontier?
  const buildFrontier = (pos) => {
    //actually, should save frontier to temp array, then filter it for validProbe ness.
    let [row, col] = pos;
    let surroundingSquares = [];
    surroundingSquares.push({
      pos: [row - 2, col], prev: pos
    });
    surroundingSquares.push({
      pos: [row, col + 2], prev: pos
    });
    surroundingSquares.push({
      pos: [row + 2, col], prev: pos
    });
    surroundingSquares.push({
      pos: [row, col - 2], prev: pos
    });
    validSurrounding = surroundingSquares.filter(probe => validProbe(probe));
    frontier = frontier.concat(validSurrounding);
  };


  //needs to store all directions maze could go

  let frontier = [];

  //Will also need a way to pop a random frontier from the array of frontier spaces

  Array.prototype.randomPop = function(){
    var i = 0, j = 0, temp = null;
    for (i = this.length - 1; i > 0; i -= 1) {
      j = Math.floor(Math.random() * (i + 1));
      temp = this[i];
      this[i] = this[j];
      this[j] = temp;
    }
    return this.pop();
  };

  //will loop until what. Say we have a count of x * y. Everytime we open a space, we decrement. nope,
  //because we dont know how many squares will be filled. Another strategy will be to go until there is
  //nothing in the frontier, meaning it would need to start off with a little push...
  const startPos = [0, 0];

  //condition could be while fronier has something in it keep going?

  const buildMaze = (start) => {
    //this is the push to get started
    openSpace(start);
    buildFrontier(start);

    while (frontier.length > 0){
      nextOpenSpace = frontier.randomPop();
      openSpace(nextOpenSpace.pos, nextOpenSpace.prev);
      //clear surrounding frontiers
      frontier = frontier.filter((probe) => {
        return surroundingPositions(nextOpenSpace.pos).every(pos => {
          return probe.pos[0] !== pos[0] || probe.pos[1] !== pos[1];
        });
      });
      //generate new frontiers
      buildFrontier(nextOpenSpace.pos);
      //eventually, do something visually
      //reloop!
    }
  };

  //lets try the timer...

  //first initialize that shit


  d3.selection.prototype.last = function() {
    var last = this.size() - 1;
    return d3.select(this[0][last]);
  };
  let pointers = new Array(50).fill(0).map(row => new Array(50).fill(0));
  function buildGrid(){
    let svgg = d3.select("#mazed")
    .append("svg")

    .style("border", "10px solid black")
    .attr("transform", "translate(10, 10 )")
    .attr("width", 490)
    .attr("height", 490);
    for (let i = 0; i < 50; i++){
      for(let j = 0; j < 50; j++ ){
        // var svgNS = "http://www.w3.org/2000/svg";

        svgg.append("rect")
        .attr({
          x: i * 10,
          y: j * 10,
          width: 10,
          height: 10,
          fill: "black"
          })
        pointers[i][j] = d3.selectAll("rect").last()[0][0];
      }
    }
  };

function paintWhite(coords){
  [row, col] = coords;
  const node = pointers[row][col]
  node.setAttribute("fill", "white");
}

buildGrid();
openSpace(startPos);
buildFrontier(startPos);

  //now we go
  stopCreating = setInterval(() => {

    if (frontier.length === 0){
      clearInterval(stopCreating);
    }

    nextOpenSpace = frontier.randomPop();
    openSpace(nextOpenSpace.pos, nextOpenSpace.prev);

    //clear surrounding frontiers
    frontier = frontier.filter((probe) => {
      return surroundingPositions(nextOpenSpace.pos).every(pos => {
        return probe.pos[0] !== pos[0] || probe.pos[1] !== pos[1];
      });
    });
    //generate new frontiers
    buildFrontier(nextOpenSpace.pos);
      // //clear surrounding frontiers

      // //generate new frontiers
      // buildFrontier(nextOpenSpace.pos);
      // var svg = d3.select("#maze")
      // .append("svg")
      // .classed("svg", true)
      // .style("border", "10px solid black")
      // .attr("transform", "translate(10, 10 )")
      // .attr("width", 490)
      // .attr("height", 490);
      // var output = svg.append("g")
      // .selectAll("g")
      // .data(grid)
      // .enter()
      // .append("g") //removing
      // .selectAll("g") // these
      // .data( function(d) { return d; } ) //lines
      // .enter() //text displays normally
      // .append("rect")
      // .attr({
      //   x: function(d,i,j) { return (i * 10); },
      //   y: function(d,i,j) { return (j * 10); },
      //   width: 10,
      //   height: 10,
      //   fill: function(d){
      //     if (d === 1) return "white";
      //     return "black";
      //   }
      // })
      // .attr("x", function(d,i,j) { return (i * 10); })
      // .attr("y", function(d,i,j) { return (j * 10); })
      // .attr("width", function(d,i,j) { return 10; })
      // .attr("height", function(d,i,j) { return 10; })
      // .attr("fill", function(d){
      //   if (d === 1) return "white";
      //   return "black";
      // })
  }, 5);
//store an array of pointers to rectangles
//create pointers when I initailize grid
//goal is to create a black grid with pointers to everyting

      </script>
      </body>
    </html>
