<!DOCTYPE html>
<html>
<head>
<title>Grid using d3.js</title>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script type="text/javascript">

</script>
</head>
<body>

<div id="maze"></div>
<div id="mazed"></div>
<svg width="500" height="500"></svg>
<script type="text/javascript" src="grid.js"></script>
<script type="text/javascript">

</script>
</body>
</html>


  <script type="text/javascript">

  const rowNum = 50;
  const colNum = 50;
  let grid = new Array(rowNum).fill(0).map(row => new Array(colNum).fill(0));


  const isInBounds = (row, col) => {
    return (row < rowNum && row >= 0) && (col < colNum && col >= 0);
  };


  intermediateSpace = (current, prev) => {
    [currentRow, currentCol] = current;
    [prevRow, prevCol] = prev;
    intermediateRow = (currentRow + prevRow) / 2;
    intermediateCol = (currentCol + prevCol) / 2;
    return [intermediateRow, intermediateCol];
  };

  const openSpace = (pos, prev) => {
    //when I've made my choice, I need to check the point I decided to move
    //to and clear any places where there is one space between two white spaces
    //aka I need to look around the space chose, and for any invalid space from
    //that space, which is pos, I need to turn the intermediate squres
    //of anything that is not valid black
    //I need to get the positions around pos
    //then I need to select invalid positions that have a free space intermed
    //those spots I paint black
    [row, col] = pos;

    grid[row][col] = 1;
    paintWhite(pos)
    if (prev) {
      [intRow, intCol] = intermediateSpace(pos, prev);
      grid[intRow][intCol] = 1;
      paintWhite([intRow, intCol]);
    }

    //take care of cleanup here
    surroundingPositions(pos).filter((surrounding) => {
      [surrX, surrY] = surrounding;
      if (!isValidSpace(surrounding)){
        [interX, interY] = intermediateSpace(pos, surrounding)
        if (grid[interX][interY] === 0){
          paintBlack([interX, interY]);
        }
      }
    })
  };

  const isValidSpace = (pos) => {
    let [row, col] = pos;
    return isInBounds(row, col) && grid[row][col] === 0;
  };

  const surroundingPositions = (pos) => {
    let [row, col] = pos;
    let positions = [];
    positions.push([row - 2, col]);
    positions.push([row, col + 2]);
    positions.push([row + 2, col]);
    positions.push([row, col - 2]);
    return positions.filter(pos => {
      return isInBounds(pos[0], pos[1]);
    });
  };



  const validProbe = (probe) => {
    if (!isValidSpace(probe.pos)) return false;
    return true;
    // let [row, col] = probe.pos;
    // if (row === 0 && col === 0) return false;
    // let [fromRow, fromCol] = probe.prev;
    // return surroundingPositions(probe.pos).every((border) => {
    //   [borderingRow, borderingCol] = border;
    //   return (fromRow === borderingRow && fromCol === borderingCol) || isValidSpace(border);
    // });
  };

  //need a function to build frontier, needs to take a move and store surrounding Positions as well as the directions.

  // when you make a new frontier, clear frontiers of all surrounding spaces and then replace with own.
  //this can be called absorb frontier?
  const buildFrontier = (pos) => {
    //actually, should save frontier to temp array, then filter it for validProbe ness.
    let [row, col] = pos;
    let surroundingSquares = [];
    surroundingSquares.push({
      pos: [row - 2, col], prev: pos
    });
    surroundingSquares.push({
      pos: [row, col + 2], prev: pos
    });
    surroundingSquares.push({
      pos: [row + 2, col], prev: pos
    });
    surroundingSquares.push({
      pos: [row, col - 2], prev: pos
    });
    validSurrounding = surroundingSquares.filter(probe => validProbe(probe));
    frontier = frontier.concat(validSurrounding);
  };


  let frontier = [];


  Array.prototype.randomPop = function(){
    var i = 0, j = 0, temp = null;
    for (i = this.length - 1; i > 0; i -= 1) {
      j = Math.floor(Math.random() * (i + 1));
      temp = this[i];
      this[i] = this[j];
      this[j] = temp;
    }
    return this.pop();
  };

  const startPos = [0, 0];


  const buildMaze = (start) => {
    openSpace(start);
    buildFrontier(start);

    while (frontier.length > 0){
      nextOpenSpace = frontier.randomPop();
      openSpace(nextOpenSpace.pos, nextOpenSpace.prev);
      frontier = frontier.filter((probe) => {
        return surroundingPositions(nextOpenSpace.pos).every(pos => {
          return probe.pos[0] !== pos[0] || probe.pos[1] !== pos[1];
        });
      });
      buildFrontier(nextOpenSpace.pos);
    }
  };




  d3.selection.prototype.last = function() {
    var last = this.size() - 1;
    return d3.select(this[0][last]);
  };
  let pointers = new Array(50).fill(0).map(row => new Array(50).fill(0));
  function buildGrid(){
    let svgg = d3.select("#mazed")
    .append("svg")

    .style("border", "10px solid black")
    .attr("transform", "translate(10, 10 )")
    .attr("width", 490)
    .attr("height", 490);
    for (let i = 0; i < 50; i++){
      for(let j = 0; j < 50; j++ ){

        svgg.append("rect")
        .attr({
          x: i * 10,
          y: j * 10,
          width: 10,
          height: 10,
          fill: "black"
          })
        pointers[i][j] = d3.selectAll("rect").last()[0][0];
      }
    }
  };

function paintWhite(coords){
  [row, col] = coords;
  const node = pointers[row][col]
  node.setAttribute("fill", "white");
}

function paintRed(coords){
  [row, col] = coords;
  const node = pointers[row][col]
  node.setAttribute("fill", "blue");
}

function paintBlack(coords){
  [row, col] = coords;
  const node = pointers[row][col];
  node.setAttribute("fill", "black");
}

buildGrid();
openSpace(startPos);
buildFrontier(startPos);

  stopCreating = setInterval(() => {

    if (frontier.length === 0){
      clearInterval(stopCreating);
    }

    nextOpenSpace = frontier.randomPop();
    openSpace(nextOpenSpace.pos, nextOpenSpace.prev);

    //clear surrounding frontiers
    frontier = frontier.filter((probe) => {
      return surroundingPositions(nextOpenSpace.pos).every(pos => {
        return probe.pos[0] !== pos[0] || probe.pos[1] !== pos[1];
      });
    });

    frontier.forEach((probe) => {
      [interRow, interCol] = intermediateSpace(probe.pos, probe.prev);
      paintRed([interRow, interCol]);
      paintRed(probe.pos);
    });
    buildFrontier(nextOpenSpace.pos);

  }, 1);

      </script>
      </body>
    </html>
